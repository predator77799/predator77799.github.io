<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ACPV on kuldeepdotexe&#39;s blog</title>
    <link>https://kuldeep.io/tags/acpv/</link>
    <description>Recent content in ACPV on kuldeepdotexe&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 20 Jul 2023 20:58:53 +0530</lastBuildDate><atom:link href="https://kuldeep.io/tags/acpv/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Escalating Privileges With SSRF</title>
      <link>https://kuldeep.io/posts/escalating-privileges-with-ssrf/</link>
      <pubDate>Thu, 20 Jul 2023 20:58:53 +0530</pubDate>
      
      <guid>https://kuldeep.io/posts/escalating-privileges-with-ssrf/</guid>
      <description>Hello again, folks!
This post is regarding my recent findings on Synack Red Team which consisted of a total of 4 SSRF vulnerabilities. Three of them were authenticated SSRFs and the last was a fully unauthenticated SSRF.
If you follow me on Twitter, you must have seen my post regarding this.
The finding is pretty straightforward. I can explain it in fewer lines but I want to explain my stepwise thought process to finding this specific vulnerability.</description>
      <content>&lt;p&gt;Hello again, folks!&lt;/p&gt;
&lt;p&gt;This post is regarding my recent findings on Synack Red Team which consisted of a total of 4 SSRF vulnerabilities. Three of them were authenticated SSRFs and the last was a fully unauthenticated SSRF.&lt;/p&gt;
&lt;p&gt;If you follow me on Twitter, you must have seen my post regarding this.&lt;/p&gt;
&lt;p&gt;The finding is pretty straightforward. I can explain it in fewer lines but I want to explain my stepwise thought process to finding this specific vulnerability. I want to do this because the target was live for a total of 11 hours and 47 minutes before I reported the vulnerability, and surprisingly no one else reported it despite the relatively small attack surface.&lt;/p&gt;
&lt;p&gt;To the blog now,&lt;/p&gt;
&lt;p&gt;I was onboarded to the target at 01:31 AM at night. I was obviously sleeping. After waking up, I realized there was a new API target. So I hopped onto my machine.&lt;/p&gt;
&lt;p&gt;I prepared the testing environment by loading the Postman collection and Postman environment files into Postman. I then started Burp Suite in order to view and manipulate the requests.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kuldeep.io/Postman-collection.png&#34; alt=&#34;Postman Collection&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;application-overview&#34;&gt;Application Overview&lt;/h3&gt;
&lt;p&gt;There were different services running on each sub-collection. By manually checking each request, I found out that there were a total of 5 services that were actually performing some sort of operation. The other collections are for authentication and other purposes.&lt;/p&gt;
&lt;p&gt;The 5 services that were running included:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;XXXIntegration&lt;/li&gt;
&lt;li&gt;AssetManagement&lt;/li&gt;
&lt;li&gt;Billing&lt;/li&gt;
&lt;li&gt;CustomerManagement&lt;/li&gt;
&lt;li&gt;OLS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To access any of these services, you require a service-specific access token. For example, if you want to access the &lt;code&gt;Billing&lt;/code&gt; service, you must have a &lt;code&gt;Billing&lt;/code&gt; access token. If you have an &lt;code&gt;AssetManagement&lt;/code&gt; access token, it will not work for the &lt;code&gt;Billing&lt;/code&gt; service and vice versa.&lt;/p&gt;
&lt;p&gt;I obtained an access token for the &lt;code&gt;AssetManagement&lt;/code&gt; service. I set the access token in the Postman environment in order to for the testing process to work properly. And I started exploring various requests.&lt;/p&gt;
&lt;h3 id=&#34;initial-discovery&#34;&gt;Initial Discovery&lt;/h3&gt;
&lt;p&gt;By manually testing each request on a one-by-one basis, I came across the &lt;code&gt;XXXService - /xxxevent&lt;/code&gt; request.&lt;/p&gt;
&lt;p&gt;The request looked like this:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;POST /api/xxx/xxxevent HTTP/1.1
Content-Type: application/json
Authorization: Bearer redacted
Host: AssetManagement-service-host
Content-Length: 507
{
  &amp;#34;event_id&amp;#34;: &amp;#34;redacted&amp;#34;,
  &amp;#34;event_type&amp;#34;: &amp;#34;redacted&amp;#34;,
  &amp;#34;event_time&amp;#34;: &amp;#34;2022-07-06T14:55:00.00Z&amp;#34;,
  &amp;#34;correlation_id&amp;#34; : &amp;#34;redacted&amp;#34;,
  &amp;#34;payload&amp;#34;: {
    &amp;#34;urls&amp;#34;: [
      {
        &amp;#34;url_type&amp;#34;: &amp;#34;XXXIntegration&amp;#34;,
        &amp;#34;url&amp;#34;: &amp;#34;https://XXXIntegration-service-host/api/xxxhistory/xxx/1234&amp;#34;
      }     
    ]
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is the explanation for each parameter:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Parameter&lt;/th&gt;
&lt;th&gt;Explanation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;event_id&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;This is a UUID for a particular event.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;event_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Set to &amp;ldquo;&lt;em&gt;public&lt;/em&gt;&amp;rdquo; by default in the collection. Most probably, this identifies if the event is public or private.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;event_time&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Describes the time of the event.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;url_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;This is set to &lt;code&gt;XXXIntegration&lt;/code&gt; showing that the &lt;code&gt;XXXIntegration&lt;/code&gt; service is being requested.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;url&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;This is the parameter of utmost interest, as this specifies an &lt;code&gt;XXXIntegration&lt;/code&gt; service URL to fetch data. A user can modify this parameter to hold any arbitrary URL and the API will send requests to that URL&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;The response to this request showed no interesting behavior as it was just a &lt;code&gt;500 Internal Server Error&lt;/code&gt; page without any verbose errors.&lt;/p&gt;
&lt;p&gt;I started testing this request by providing it with a Synack Burp Collaborator URL. And, to my surprise, it actually sent me an HTTP request.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kuldeep.io/request-to-collaborator.png&#34; alt=&#34;Request In Collaborator&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;initial-assumption-and-its-limitations&#34;&gt;Initial Assumption and Its Limitations&lt;/h3&gt;
&lt;p&gt;Just like you, I also noticed the authorization token in the request. But at the time of testing, I assumed this was my own authorization token. I believed the server forwarded parts of my request to the URL provided as the &lt;code&gt;url&lt;/code&gt; parameter.&lt;/p&gt;
&lt;p&gt;This kind of behavior has almost no impact on its own because stealing our own bearer token yields nothing. It must be chained with some other attack like CSRF in order to exploit other users. For example, it can be exploited when you make the victim send a request to an attacker-controlled domain.&lt;/p&gt;
&lt;h3 id=&#34;bypassing-the-blacklist-to-achieve-a-partial-ssrf&#34;&gt;Bypassing The Blacklist To Achieve A Partial SSRF&lt;/h3&gt;
&lt;p&gt;I ignored this behavior and started checking if I can do a local port scan for it to be eligible for a partial SSRF. I tried to make the API send a request to &lt;code&gt;localhost&lt;/code&gt; but the API had a blacklist in place for such payloads. I tried a handful of payloads like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;localhost&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;127.0.0.1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0.0.0.0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;127.1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;But as expected, all were being filtered by the API.&lt;/p&gt;
&lt;p&gt;This API was allowing requests to arbitrary domains so I thought to try a domain name that resolved to &lt;code&gt;127.0.0.1&lt;/code&gt;. So, I tried it again with the &lt;code&gt;localtest.me&lt;/code&gt; domain and it successfully bypassed the blacklist. I confirmed that it bypassed the blacklist by the &lt;code&gt;500 Internal Server Error&lt;/code&gt; response. Normally, if the API filtered the payload, it sent a &lt;code&gt;403 Forbidden&lt;/code&gt; response.&lt;/p&gt;
&lt;p&gt;API normally:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kuldeep.io/api-filtering-localhost.png&#34; alt=&#34;API Throwing A 403 When Supplied with 0.0.0.0&#34;&gt;&lt;/p&gt;
&lt;p&gt;API when I use localtest.me:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kuldeep.io/api-filtering-localhost-bypassed.png&#34; alt=&#34;API Blacklisting Bypass Using localtest.me&#34;&gt;&lt;/p&gt;
&lt;p&gt;Now, all I had to do was create a local port scan PoC and submit it as a partial SSRF. However, I decided to escalate this issue in order for a better payout. I kept this vulnerability aside and started checking other functionalities that could potentially be used to exploit the SSRF.&lt;/p&gt;
&lt;h3 id=&#34;attempting-to-understand-jwt&#34;&gt;Attempting To Understand JWT&lt;/h3&gt;
&lt;p&gt;At random, a thought clicked in my brain. I wanted to confirm if the bearer token that I received in the collaborator indeed belonged to me. I later confirmed that the bearer token in the collaborator was different from the one that I had in my request.&lt;/p&gt;
&lt;p&gt;I used &lt;a href=&#34;https://jwt.io/&#34;&gt;jwt.io&lt;/a&gt; to decode both the tokens and compared them side by side. And this comparison further confirmed my belief that both the tokens are different. I will not show a screenshot of this for obvious reasons.&lt;/p&gt;
&lt;p&gt;Even after confirming that the token is from a different user/service, I still had no idea where this token was being used. I thought to fuzz all API endpoints of all services with this bearer token to see if any of them respond with a &lt;code&gt;200 OK&lt;/code&gt; or even anything apart from &lt;code&gt;401 Unauthorized&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;finding-services-to-use-the-jwt&#34;&gt;Finding Services To Use The JWT&lt;/h3&gt;
&lt;p&gt;As usual, I got lazy and started looking for alternatives to fuzzing. Also, fuzzing must be the last resort in this situation because there were endpoints that performed different CRUD operations. Any wrong request can break the API.&lt;/p&gt;
&lt;p&gt;After checking each request manually for a while, a thought randomly clicked in my brain, once again. Let&amp;rsquo;s revisit our vulnerable request:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{
	&amp;#34;url_type&amp;#34;: &amp;#34;XXXIntegration&amp;#34;,
	&amp;#34;url&amp;#34;: &amp;#34;https://XXXIntegration-service-host/api/xxxhistory/xxx/1234&amp;#34;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here, &lt;code&gt;XXXIntegration&lt;/code&gt; specifies that we are requesting the &lt;code&gt;XXXIntegration&lt;/code&gt; service. If you notice, the &lt;code&gt;XXXIntegration&lt;/code&gt; service is there in the 5 services that I listed at the start of the blog. And the &lt;code&gt;XXXIntegration-service-host&lt;/code&gt; is a host for the same service.&lt;/p&gt;
&lt;p&gt;So, my hypothesis was that if the original request was being sent to the &lt;code&gt;XXXIntegration-service-host&lt;/code&gt; host, then this access token must also belong to the same service.&lt;/p&gt;
&lt;p&gt;To confirm this theory, I copied the authorization token received in the collaborator and pasted it into the health check endpoint of the &lt;code&gt;XXXIntegration-service-host&lt;/code&gt; host. The health check endpoint was the perfect to test for this. The reason behind this is that it returned a &lt;code&gt;401 Unauthorized&lt;/code&gt; response if the credentials are invalid and a &lt;code&gt;200 OK&lt;/code&gt; response if the credentials are valid.&lt;/p&gt;
&lt;p&gt;After setting the authorization token, I successfully received a &lt;code&gt;200 OK&lt;/code&gt;. This confirmed that the token that was leaked in collaborator belonged to the &lt;code&gt;XXXIntegration&lt;/code&gt; service.&lt;/p&gt;
&lt;p&gt;Before setting the authorization token:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kuldeep.io/healthcheck-before-setting-token.png&#34; alt=&#34;API showing a 401 before setting the authorization token&#34;&gt;&lt;/p&gt;
&lt;p&gt;After setting the authorization token leaked in the collaborator:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kuldeep.io/healthcheck-after-setting-token.png&#34; alt=&#34;API showing a 200 OK after setting the authorization token&#34;&gt;&lt;/p&gt;
&lt;p&gt;This proved that the authorization token can be used to interact with the &lt;code&gt;XXXIntegration&lt;/code&gt; service. However, just to make sure that it can not be accessed with any valid access token, I sent a request to the health check endpoint of the &lt;code&gt;XXXIntegration&lt;/code&gt; service with an access token for the &lt;code&gt;AssetManagement&lt;/code&gt; service. This failed because the application had proper access control checks in place.&lt;/p&gt;
&lt;p&gt;Also, I later confirmed that we can exfiltrate an access token of ANY service by specifying the service name in the &lt;code&gt;url_type&lt;/code&gt; parameter. If you replace &lt;code&gt;XXXIntegration&lt;/code&gt; with &lt;code&gt;Billing&lt;/code&gt; in the vulnerable request, the collaborator request will yield a Billing service access token.&lt;/p&gt;
&lt;p&gt;Now we have everything we need to craft a full SSRF report.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A request to an arbitrary URL&lt;/li&gt;
&lt;li&gt;API leaking access token of another service&lt;/li&gt;
&lt;li&gt;Privilege escalation using the access token&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;finding-even-more-scarier-ssrfs&#34;&gt;Finding Even More (Scarier) SSRFs&lt;/h3&gt;
&lt;p&gt;I started writing a report on this issue. But I accidentally closed all my tabs in Postman. I used the &amp;ldquo;filter&amp;rdquo; option in Postman to search for the &amp;ldquo;event&amp;rdquo; keyword hoping to find the vulnerable endpoint. But instead, I was greeted with 9 such endpoints that ended with &amp;ldquo;event&amp;rdquo;. I checked all of them and found out that all of them were vulnerable.&lt;/p&gt;
&lt;p&gt;Now, instead of writing one report, I had to write 4 different reports. I wrote the first three reports. And then moved on to the next and final report. This is where I was so shocked that I could not believe what I was seeing.&lt;/p&gt;
&lt;p&gt;The last endpoint was accessible without any sort of authentication. The request to it looked like this:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;POST /api/xxx/xxxevent HTTP/1.1
Content-Type: application/json
Host: CustomerManagement-service-host
Content-Length: 622

{
	&amp;#34;event_id&amp;#34;: &amp;#34;redacted&amp;#34;,
	&amp;#34;event_type&amp;#34;: &amp;#34;redacted&amp;#34;,
	&amp;#34;event_time&amp;#34;: &amp;#34;2022-08-30T09:00:00.0000000Z&amp;#34;,
	&amp;#34;correlation_id&amp;#34;: &amp;#34;redacted&amp;#34;,
	&amp;#34;payload&amp;#34;: {
		&amp;#34;urls&amp;#34;: [
      {
        &amp;#34;url_type&amp;#34;: &amp;#34;CustomerManagement&amp;#34;,
        &amp;#34;url&amp;#34;: &amp;#34;https://CustomerManagement-service-host/api/xxx/customer/1234&amp;#34;
      },
			{
				&amp;#34;url_type&amp;#34;: &amp;#34;XXXIntegration&amp;#34;,
				&amp;#34;url&amp;#34;: &amp;#34;https://XXXIntegration-service-host/api/xxxhistory/xxx/1234&amp;#34;
			}
		]
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Any form of authentication was not required to access this endpoint. So, it allowed a remote unauthenticated attacker to obtain valid authorization tokens for different services. All an attacker has to do is tell the server about the service he/she wants to interact with and a URL to send the authenticated access token. The server will send the credentials without asking for anything. It&amp;rsquo;s that simple. And it&amp;rsquo;s that scary.&lt;/p&gt;
&lt;p&gt;Sent all four reports to Synack and they accepted them happily with a generous bounty amount.&lt;/p&gt;
&lt;h3 id=&#34;conclusiontakeaways&#34;&gt;Conclusion/Takeaways&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Manually check for small details/anomalies. This may or may not lead to vulnerabilities. But it can certainly help you escalate the severity of the issue.&lt;/li&gt;
&lt;li&gt;Always try to increase the severity of your finding. Never settle for a lower severity vulnerability. Take the help of your fellow hackers if you need to.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I work full-time as a bug bounty hunter mostly hacking in Synack Red Team (SRT). If you&amp;rsquo;re interested in becoming a part of the Synack Red Team, feel free to connect with me on Twitter, Instagram, or LinkedIn. I&amp;rsquo;m always happy to offer guidance to fellow cybersecurity enthusiasts.&lt;/p&gt;
&lt;p&gt;EOF&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Holiday Hunting With Aquatone</title>
      <link>https://kuldeep.io/posts/holiday-hunting-with-aquatone/</link>
      <pubDate>Fri, 03 Mar 2023 01:09:16 +0530</pubDate>
      
      <guid>https://kuldeep.io/posts/holiday-hunting-with-aquatone/</guid>
      <description>Hello, folks!
Before going to the blog, I would like to give a little context on what happened here. I went on a workcation in April 2022 with my hacker friends (@N0_M3ga_Hacks, @AyushBawariya1 and @x30r_). We hacked during the day and partied in the evenings.
One day, I was telling @N0_M3ga_Hacks about how easy it was to hunt on a specific target in Synack Red Team. That it was full of vulnerabilities.</description>
      <content>&lt;p&gt;Hello, folks!&lt;/p&gt;
&lt;p&gt;Before going to the blog, I would like to give a little context on what happened here. I went on a workcation in April 2022 with my hacker friends (&lt;a href=&#34;https://twitter.com/N0_M3ga_Hacks&#34;&gt;@N0_M3ga_Hacks&lt;/a&gt;, &lt;a href=&#34;https://twitter.com/AyushBawariya1&#34;&gt;@AyushBawariya1&lt;/a&gt; and &lt;a href=&#34;https://twitter.com/x30r_&#34;&gt;@x30r_&lt;/a&gt;). We hacked during the day and partied in the evenings.&lt;/p&gt;
&lt;p&gt;One day, I was telling &lt;a href=&#34;https://twitter.com/N0_M3ga_Hacks&#34;&gt;@N0_M3ga_Hacks&lt;/a&gt; about how easy it was to hunt on a specific target in Synack Red Team. That it was full of vulnerabilities. I was telling him that I have found many vulnerabilities just by running &lt;a href=&#34;https://github.com/michenriksen/aquatone&#34;&gt;aquatone&lt;/a&gt; on the in-scope HTTP servers. I did not even need to do a port scan to find other HTTP services on different ports like 8443,8080 etc.&lt;/p&gt;
&lt;p&gt;While telling him about this, I thought, &amp;ldquo;Let me show him in practice&amp;rdquo; and I  went ahead and ran &lt;a href=&#34;https://github.com/projectdiscovery/httpx&#34;&gt;httpx&lt;/a&gt; on all the in-scope IPs and found live HTTP services. Then I ran aquatone across all the IPs.&lt;/p&gt;
&lt;p&gt;From here, we found a total of 3 vulnerabilities that are as documented below:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Vulnerability Title&lt;/th&gt;
&lt;th&gt;Reward&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SSRF Allowing To Access Google VM Metadata&lt;/td&gt;
&lt;td&gt;$2400&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SSRF Allowing To Access Internal Ports&lt;/td&gt;
&lt;td&gt;$500&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Exposed XXXX Portal Revealing Tickets&lt;/td&gt;
&lt;td&gt;$705&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;ssrf-allowing-to-access-google-vm-metadata&#34;&gt;SSRF Allowing To Access Google VM Metadata&lt;/h3&gt;
&lt;p&gt;What stood out from the aquatone results was a web page test application. The web root of the application looked like the following:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kuldeep.io/WebPageTest-webroot.png&#34; alt=&#34;WebPageTest&#34;&gt;&lt;/p&gt;
&lt;p&gt;It asked us for a website URL to &amp;ldquo;start test&amp;rdquo;. I did not know what kind of test this was going to perform. For example, I just gave it &lt;a href=&#34;https://example.com&#34;&gt;https://example.com&lt;/a&gt; and saw what it did.&lt;/p&gt;
&lt;p&gt;The application did something for a while and then gave me a nice screenshot of &lt;a href=&#34;https://example.com&#34;&gt;https://example.com&lt;/a&gt; with a lot of other performance metrics that I did not really know about or care enough to check.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kuldeep.io/example-com-results.png&#34; alt=&#34;https://example.com results&#34;&gt;&lt;/p&gt;
&lt;p&gt;What I got interested in was the screenshot of &lt;a href=&#34;https://example.com&#34;&gt;https://example.com&lt;/a&gt;. The application sent a request to &lt;a href=&#34;https://example.com&#34;&gt;https://example.com&lt;/a&gt; and gave us its screenshot.&lt;/p&gt;
&lt;p&gt;This is the intended behavior of the application and the ability to request arbitrary URLs is not a vulnerability in itself. The vulnerability arises when the application makes requests to restricted URLs like cloud metadata URLs or localhost that DO have sensitive information exposed.&lt;/p&gt;
&lt;p&gt;Happy with what I saw, I gave it https://127.0.0.1 to &amp;ldquo;start test&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;It again did something for a while and gave me the results. This time, the results were quite disappointing.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kuldeep.io/localhost-results.png&#34; alt=&#34;127.0.0.1 Results&#34;&gt;&lt;/p&gt;
&lt;p&gt;It showed an error saying &amp;ldquo;This site can&amp;rsquo;t be reached&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;I sent the request to Burp Suite Intruder and started doing a port scan of the top 1000 ports but it was taking a lot of time. All of these tests were taking 2-3 minutes to complete. Even if we consider the best case of 2 minutes to complete a test, we still require 2000 minutes which is 33.33 hours to perform a port scan of just 1000 ports.&lt;/p&gt;
&lt;p&gt;This was the wrong way. To find a workaround, I played with the application&amp;rsquo;s settings and found an option to disable these &amp;ldquo;tests&amp;rdquo; that I thought took most of the time.&lt;/p&gt;
&lt;p&gt;I disabled the tests and tried again. But the delay of 2-3 minutes was still there despite the tests being on or off. So I believe that it was some kind of internet issue or browser issue.&lt;/p&gt;
&lt;p&gt;However, while testing this, I made a huge mess. Before you could submit a new URL to test, all the old URL tests were supposed to be finished. If they are not finished then the new URL tests will stay pending. And previously, I had sent 1000 requests to the server for port scanning.&lt;/p&gt;
&lt;p&gt;This means I cannot test further without waiting for 33.33 hours. I wished someone would reboot the server so that I did not have to wait that long but the server seemed to be unused as no one sent any tests during these 33.33 hours. I also checked the old tests but there were no tests before I sent mine.&lt;/p&gt;
&lt;p&gt;After two days, I checked and all the tests were finished. I scraped the results, found all the screenshots, and downloaded them.&lt;/p&gt;
&lt;p&gt;Upon checking all the screenshots, I was disappointed once again as none of the ports were running HTTP services. Even after waiting for two days to see the results, nothing was found.&lt;/p&gt;
&lt;p&gt;I tried the &lt;code&gt;file://&lt;/code&gt; protocol to retrieve &lt;code&gt;/etc/passwd&lt;/code&gt; but that also did not work.&lt;/p&gt;
&lt;p&gt;I went ahead to try and retrieve the cloud metadata. This should have been the most obvious choice to me as the client hosted all their infrastructure on GCP. But while hacking this, I was more curious about internally exposed services than cloud metadata.&lt;/p&gt;
&lt;p&gt;To retrieve Google metadata, we need to request &lt;a href=&#34;http://metadata.google.internal/computeMetadata/v1/&#34;&gt;http://metadata.google.internal/computeMetadata/v1/&lt;/a&gt; URL with two custom headers that are as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;X-Google-Metadata-Request: True&lt;/li&gt;
&lt;li&gt;Metadata-Flavor: Google&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Luckily, the application also provided functionality to add additional headers before you start the web page test.&lt;/p&gt;
&lt;p&gt;I added the headers and started the test on &lt;a href=&#34;http://metadata.google.internal/computeMetadata/v1/&#34;&gt;http://metadata.google.internal/computeMetadata/v1/&lt;/a&gt; URL. It took more than 2-3 minutes to finish this time so I got excited. But I was once again met with disappointment as this resulted in an empty screenshot.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kuldeep.io/metadata-v1-results.png&#34; alt=&#34;/computeMetadata/v1 Results&#34;&gt;&lt;/p&gt;
&lt;p&gt;I gave up with the cloud metadata thing and tried to check a few common ports like 8080, 8125, 80, 5000, etc. This also resulted in the same output as my previous attempts for a port scan. I decided to step away from this and take a little break.&lt;/p&gt;
&lt;p&gt;After 5 days, I was again hooked on retrieving the Google metadata. This time I tried with several other endpoints like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/computeMetadata/v1/instance/hostname&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/computeMetadata/v1/instance/id&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/computeMetadata/v1/instance/image&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The list goes on but you get the point. I tried many other endpoints. I also used the much useful &lt;a href=&#34;https://gist.github.com/jhaddix/78cece26c91c6263653f31ba453e273b&#34;&gt;Cloud Metadata Wordlist Gist&lt;/a&gt;. However, none of these endpoints seemed to work in my case.&lt;/p&gt;
&lt;p&gt;I then simply googled &amp;ldquo;google cloud metadata&amp;rdquo; and the very first result was the &lt;a href=&#34;https://cloud.google.com/compute/docs/metadata/querying-metadata&#34;&gt;official documentation&lt;/a&gt; on how to access the VM metadata. As I was reading it, it mentioned the following endpoint:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/computeMetadata/v1/instance/tags&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I gave the same endpoint to the application for testing and to my surprise, it gave me the output!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kuldeep.io/metadata-v1-instance-tags-results.png&#34; alt=&#34;/computeMetadata/v1/instance/tags Results&#34;&gt;&lt;/p&gt;
&lt;p&gt;Here, the screenshot quality was really bad. It was too small that it was unreadable. To view metadata that makes some sense to us, we need to find some other way.&lt;/p&gt;
&lt;p&gt;After poking around with different features, I found one way to view the resulting HTML content. All I had to do was to click on the &amp;ldquo;View JSON result&amp;rdquo; button. After clicking, the application showed the performance metrics and all the other information in JSON format.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kuldeep.io/view-JSON-results.png&#34; alt=&#34;View JSON results&#34;&gt;&lt;/p&gt;
&lt;p&gt;Here, I was able to see the resulting HTML content in a JSON field called &amp;ldquo;html&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;I again checked the &lt;a href=&#34;https://gist.github.com/jhaddix/78cece26c91c6263653f31ba453e273b&#34;&gt;Cloud Metadata Wordlist Gist&lt;/a&gt; and found out that I did not check one endpoint shown in the wordlist. It was the following endpoint:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/computeMetadata/v1/instance/disks/?recursive=true&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I quickly entered this endpoint and checked the HTML in JSON result and found out that it successfully listed all the disks!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kuldeep.io/metadata-v1-instance-disks-results.png&#34; alt=&#34;/computeMetadata/v1/instance/disks Results&#34;&gt;&lt;/p&gt;
&lt;p&gt;Reported this with all the required pieces of evidence and this was accepted.&lt;/p&gt;
&lt;p&gt;The same application offered other functionalities like running a custom testing script, bulk testing, bulk testing using file upload, etc. And all of them were vulnerable to this.&lt;/p&gt;
&lt;p&gt;I will not be explaining each of them but an exploit using a custom testing script looked like this:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;addHeader Metadata-Flavor: Google
navigate http://metadata.google.internal/computeMetadata/v1/instance/disks/?recursive=true
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;ssrf-allowing-to-access-internal-ports&#34;&gt;SSRF Allowing To Access Internal Ports&lt;/h3&gt;
&lt;p&gt;The web application root of this IP showed a search functionality as shown below.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kuldeep.io/search-functionality.png&#34; alt=&#34;Web Application Root&#34;&gt;&lt;/p&gt;
&lt;p&gt;Here, you can see that a URL is shown beside the &amp;ldquo;cluster&amp;rdquo; drop-down. We can change the cluster dropdown to other options that will change the URL. My best guess is that we can change the cluster to switch between dev/prod environments.&lt;/p&gt;
&lt;p&gt;Upon searching a string &amp;ldquo;test&amp;rdquo;, a POST request to the &lt;code&gt;/search&lt;/code&gt; endpoint is sent along with a lot of other parameters.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kuldeep.io/search-request.png&#34; alt=&#34;Search Request&#34;&gt;&lt;/p&gt;
&lt;p&gt;A detailed breakdown of a few crucial parameters is shown below:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Parameter&lt;/th&gt;
&lt;th&gt;Explanation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;url&lt;/td&gt;
&lt;td&gt;This was the URL to which the search request was sent. If you change the cluster using the drop-down, this URL will change.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sortby&lt;/td&gt;
&lt;td&gt;This was the column/criteria on which the result would be sorted.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;sortorder&lt;/td&gt;
&lt;td&gt;Ascending or descending depending on the value.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;keyword&lt;/td&gt;
&lt;td&gt;The keyword to search in the cluster.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;page&lt;/td&gt;
&lt;td&gt;This was used for pagination purposes.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;storeid&lt;/td&gt;
&lt;td&gt;The store identifier in which we had to search&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;From the parameters, I assumed that a sequence similar to the following might be used by the web application:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kuldeep.io/SequenceDiagram.png&#34; alt=&#34;Sequence Diagram&#34;&gt;&lt;/p&gt;
&lt;p&gt;Here, the &lt;code&gt;url&lt;/code&gt; parameter directly clicked as an SSRF in my head but I kept it in side and started hunting for SQL injections.&lt;/p&gt;
&lt;p&gt;I tested all the parameters and all the cluster URLs to see if any of them is vulnerable to an SQL injection or not. But all of them were secure and SQL injection was not possible in any of the clusters.&lt;/p&gt;
&lt;p&gt;Now, back to the SSRF, I changed the &lt;code&gt;url&lt;/code&gt; parameter to my TUPoC URL and I saw that the server now responded with a &lt;code&gt;JSONDecodeError&lt;/code&gt; and a detailed stack trace.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kuldeep.io/JSONDecodeException.png&#34; alt=&#34;JSONDecodeError&#34;&gt;&lt;/p&gt;
&lt;p&gt;You may be wondering, &amp;ldquo;Why does this exception occur?&amp;rdquo; This is because the web application is trying to JSON decode the data returned from our TUPoC URL but our TUPoC URL is not sending valid JSON data. It is sending normal HTML.&lt;/p&gt;
&lt;p&gt;By taking advantage of this verbose error, we can enumerate open HTTP services on the vulnerable server.&lt;/p&gt;
&lt;p&gt;The thought process behind this is that, if a web service is running on the server, it will return some HTML data. The web application will try to JSON decode HTML data and hence an exception will be thrown. This way, we can enumerate open HTTP ports.&lt;/p&gt;
&lt;p&gt;I quickly sent the request to Burp Suite Intruder and changed the &lt;code&gt;url&lt;/code&gt; parameter to &lt;code&gt;http://127.0.0.1:ยง1ยง&lt;/code&gt; and ran intruder from 1 to 5000 to fuzz the top 5000 ports.&lt;/p&gt;
&lt;p&gt;Once the attack was complete, I found that port 5000 was open and running the vulnerable service.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kuldeep.io/5000-port-open.png&#34; alt=&#34;5000 Port Open&#34;&gt;&lt;/p&gt;
&lt;p&gt;All the other ports returned a &lt;code&gt;ConnectionError&lt;/code&gt; exception.&lt;/p&gt;
&lt;h3 id=&#34;exposed-xxxx-portal-revealing-tickets&#34;&gt;Exposed XXXX Portal Revealing Tickets&lt;/h3&gt;
&lt;p&gt;Once again, the web root of this host showed some kind of dashboard that I found interesting.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kuldeep.io/portal-root.png&#34; alt=&#34;Portal Web Root&#34;&gt;&lt;/p&gt;
&lt;p&gt;It was showing different functionalities like incidents, tickets, changes, etc. The API was restricting access to some of the functionalities. However, only some of the functionalities were protected and most of the functionalities were accessible without any sort of authentication.&lt;/p&gt;
&lt;p&gt;Here, I was able to view all the open tickets.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://kuldeep.io/portal-tickets.png&#34; alt=&#34;Portal Tickets&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;takeaways&#34;&gt;Takeaways&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Collaborate with like-minded people.&lt;/li&gt;
&lt;li&gt;Do not give up if your way of exploiting does not work. Take a break and try again.&lt;/li&gt;
&lt;li&gt;Hacking is not as easy as I made it seem in this blog post. Sometimes I hack for more than 12 hours without finding a vulnerability or even something to play with. And sometimes I get lucky and find multiple vulnerabilities with something as simple as aquatone.&lt;/li&gt;
&lt;li&gt;Take vacations/holidays.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thanks for reading. :)&lt;/p&gt;
&lt;p&gt;If you have any questions, you can reach me out on Twitter at &lt;a href=&#34;https://twitter.com/kuldeepdotexe&#34;&gt;@kuldeepdotexe&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Happy hacking!&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>120 Days of High Frequency Hunting</title>
      <link>https://kuldeep.io/posts/120-days-of-high-frequency-hunting/</link>
      <pubDate>Sat, 15 Jan 2022 20:50:13 +0530</pubDate>
      
      <guid>https://kuldeep.io/posts/120-days-of-high-frequency-hunting/</guid>
      <description>Hi, guys!
I and @caffeinevulns took inspiration from @infosec_au&amp;rsquo;s blog about high-frequency bug hunting and how he found 120 bugs in 120 days. After going through the blog, we decided to try to find 120 bugs in 120 days. Although we did not exactly succeed in finding 120 bugs in 120 days, we still found pretty nice bugs. This blog will be a transparent disclosure of all the bugs I found on Synack Red Team during these 120 days and a small write-up about the techniques I used to find/exploit them.</description>
      <content>&lt;p&gt;Hi, guys!&lt;/p&gt;
&lt;p&gt;I and &lt;a href=&#34;https://twitter.com/caffeinevulns&#34;&gt;@caffeinevulns&lt;/a&gt; took inspiration from &lt;a href=&#34;https://twitter.com/infosec_au&#34;&gt;@infosec_au&lt;/a&gt;&amp;rsquo;s &lt;a href=&#34;https://shubs.io/high-frequency-security-bug-hunting-120-days-120-bugs/&#34;&gt;blog&lt;/a&gt; about high-frequency bug hunting and how he found 120 bugs in 120 days. After going through the blog, we decided to try to find 120 bugs in 120 days. Although we did not exactly succeed in finding 120 bugs in 120 days, we still found pretty nice bugs. This blog will be a transparent disclosure of all the bugs I found on Synack Red Team during these 120 days and a small write-up about the techniques I used to find/exploit them.&lt;/p&gt;
&lt;p&gt;This particular write-up is limited to my bugs only due to length concerns. However, you can find &lt;a href=&#34;https://twitter.com/caffeinevulns&#34;&gt;@caffeinevulns&lt;/a&gt;&amp;rsquo; bugs on his blog at &lt;a href=&#34;https://coffeejunkie.me/&#34;&gt;https://coffeejunkie.me/&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;For summarising, I found a total of 36 valid vulnerabilities and performed 29 missions and 29 patch verifications. Please note that I have not included duplicate and low-impact findings that were rejected. I originally decided to include them as well but then I felt lazy because I had to go through all the submissions once again and it was not worth the effort for rejected submissions.&lt;/p&gt;
&lt;h3 id=&#34;submissions&#34;&gt;Submissions&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Transaction&lt;/th&gt;
&lt;th&gt;Date&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://kuldeep.io/posts/120-days-of-high-frequency-hunting/#ac-in-reportspostsphp-leaking-pii&#34;&gt;AC in /reports/posts.php Leaking PII&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Aug 05, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://kuldeep.io/posts/120-days-of-high-frequency-hunting/#misconfigured-web-server-leaks-admin-functionalities-in-302-response-body&#34;&gt;Misconfigured Web Server Leaks Admin Functionalities In 302 Response Body&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Aug 05, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Unauthenticated SQL Injection in [REDACTED] on owner and scheme parameters&lt;/td&gt;
&lt;td&gt;Aug 05, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Debug Flag Allows for viewing of Database Credentials&lt;/td&gt;
&lt;td&gt;Aug 19, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Debug Flag Allows To See Database Credentials&lt;/td&gt;
&lt;td&gt;Aug 19, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Debug Flag Allows To See Database Credentials&lt;/td&gt;
&lt;td&gt;Aug 23, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Root Detection Bypass Using Frida&lt;/td&gt;
&lt;td&gt;Sep 15, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Wordpress Login Panel&lt;/td&gt;
&lt;td&gt;Sep 15, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Exposed Drupal Login Panel&lt;/td&gt;
&lt;td&gt;Sep 16, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://kuldeep.io/posts/120-days-of-high-frequency-hunting/#multiple-time-based-sql-injections&#34;&gt;Multiple Time Based SQL Injections&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Sep 17, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spring Boot Path Traversal - CVE-2020-5410&lt;/td&gt;
&lt;td&gt;Sep 21, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://kuldeep.io/posts/120-days-of-high-frequency-hunting/#reflected-xss-via-e-mail-parameter-with-aspnet-waf-bypass&#34;&gt;Reflected XSS via E-Mail parameter with ASP.NET WAF Bypass&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Sep 23, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Outdated Jira instance leaking PII information&lt;/td&gt;
&lt;td&gt;Sep 24, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://kuldeep.io/posts/120-days-of-high-frequency-hunting/#login-authentication-bypass-in-client-side-ui&#34;&gt;Login Authentication Bypass In Client Side UI&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Sep 28, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://kuldeep.io/posts/120-days-of-high-frequency-hunting/#access-control-issue-allows-to-execute-sql-statements&#34;&gt;Access Control Issue Allows To Execute SQL Statements&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Sep 28, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Reflected XSS Via URL on [REDACTED]&lt;/td&gt;
&lt;td&gt;Sep 30, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Reflected XSS Via key Parameter on [REDACTED]/admin/core/html/google_api_lang.php&lt;/td&gt;
&lt;td&gt;Sep 30, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Reflected XSS Via POST Body&lt;/td&gt;
&lt;td&gt;Sep 30, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Config Backup Disclosing Cpanel Passwords&lt;/td&gt;
&lt;td&gt;Sep 30, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Folder Backup Exposing CVs&lt;/td&gt;
&lt;td&gt;Oct 01, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://kuldeep.io/posts/120-days-of-high-frequency-hunting/#connectors-endpoints-leaking-database-connection-information&#34;&gt;/connectors endpoints leaking Database Connection Information&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Oct 01, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IDOR Exposing CVs and PII&lt;/td&gt;
&lt;td&gt;Oct 01, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WordPress Login Panel&lt;/td&gt;
&lt;td&gt;Oct 05, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Exposed Drupal Login Panel&lt;/td&gt;
&lt;td&gt;Oct 06, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Admin Panel Disclosure&lt;/td&gt;
&lt;td&gt;Oct 13, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Multiple Time Based SQL Injections&lt;/td&gt;
&lt;td&gt;Oct 13, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://kuldeep.io/posts/120-days-of-high-frequency-hunting/#local-file-inclusion-in-downloadphp&#34;&gt;Local File Inclusion In download.php&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Oct 14, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Default Admin Credentials On Nagios Server&lt;/td&gt;
&lt;td&gt;Oct 28, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Multiple Exposed Files Disclosing Confidential Information&lt;/td&gt;
&lt;td&gt;Oct 28, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://kuldeep.io/posts/120-days-of-high-frequency-hunting/#ssrf-allowing-to-access-internal-service&#34;&gt;SSRF Allowing To Access Internal Service&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Nov 02, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://kuldeep.io/posts/120-days-of-high-frequency-hunting/#ssrf-allowing-to-access-internal-service&#34;&gt;SSRF Allowing To Access Internal Service&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Nov 02, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IDOR Allows To Read Order Details&lt;/td&gt;
&lt;td&gt;Nov 04, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IDOR Allows To Read Order Details&lt;/td&gt;
&lt;td&gt;Nov 04, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Reflected XSS With WAF Bypass&lt;/td&gt;
&lt;td&gt;Nov 10, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Multiple IDORs Allowing To Modify Endpoint Details&lt;/td&gt;
&lt;td&gt;Nov 11, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://kuldeep.io/posts/120-days-of-high-frequency-hunting/#pre-auth-server-side-request-forgery&#34;&gt;Pre-auth Server Side Request Forgery&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Nov 24, 2021&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Patch Verifications(29)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Missions(29)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;analysis&#34;&gt;Analysis&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Category&lt;/th&gt;
&lt;th&gt;Vuln Count&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Information Disclosure&lt;/td&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Cross Site Scripting&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Access/Privacy Control Violation&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Insecure Direct Object Reference&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SQL Injection&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Server Side Request Forgery&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Path Traversal/Local File Inclusion&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Default Credentials&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Root/Jailbreak Detection Bypass&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;brief-descriptions&#34;&gt;Brief Descriptions&lt;/h2&gt;
&lt;h4 id=&#34;ac-in-reportspostsphp-leaking-pii&#34;&gt;AC in /reports/posts.php Leaking PII&lt;/h4&gt;
&lt;p&gt;The PHP script &lt;strong&gt;/reports/posts.php&lt;/strong&gt; accepted a numeric POST parameter named &lt;code&gt;scheme&lt;/code&gt; which returned the residential address of users. I used the following command to enumerate different IDs and return addresses associated with the ID:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; id in &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;seq &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; 50&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt; curl https://&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;REDACTED&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;/reports/posts.php -X POST -d &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;scheme%5B%5D=&lt;/span&gt;$id&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;amp;custom=&amp;amp;create=Posts&amp;#34;&lt;/span&gt; --silent | sed &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1,2d&amp;#39;&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;done&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The above command will return addresses of users having IDs ranging from 1 to 50.&lt;/p&gt;
&lt;h4 id=&#34;misconfigured-web-server-leaks-admin-functionalities-in-302-response-body&#34;&gt;Misconfigured Web Server Leaks Admin Functionalities In 302 Response Body&lt;/h4&gt;
&lt;p&gt;This was the famous execute after redirect issue in PHP. The server had many PHP scripts that when visited, redirected to the login page. However, the 302 redirects also had the body contents of the same PHP script. Due to this, an attacker could access protected pages that leaked the admin functionality.&lt;/p&gt;
&lt;p&gt;I got around the redirect issue by adding the following match and replace rule in Burp:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Field&lt;/th&gt;
&lt;th&gt;Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Type&lt;/td&gt;
&lt;td&gt;Response header&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Match&lt;/td&gt;
&lt;td&gt;Location: https://[REDACTED].com&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Replace&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Comment&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Note: &lt;code&gt;Replace&lt;/code&gt; and &lt;code&gt;Comment&lt;/code&gt; fields are empty.&lt;/p&gt;
&lt;h4 id=&#34;multiple-time-based-sql-injections&#34;&gt;Multiple Time Based SQL Injections&lt;/h4&gt;
&lt;p&gt;This particular finding was very interesting because although it was pretty straightforward, &lt;code&gt;sqlmap&lt;/code&gt; was still not able to exploit it. For this vulnerability, I had to manually enumerate the database and dump information. It was a time-based SQL injection so it required a lot of patience to get something meaningful out of the database.&lt;/p&gt;
&lt;p&gt;I first confirmed the SQL injection using the same special character fuzzing. However, this time, the application did not throw an SQL error when we sent a single quote. Instead, the response content was changed. Normally, the page would respond with 400 bad request. But if you send a single quote in the parameter, the response code changed from 400 to 500 hinting at an SQL injection. Now, if we do &lt;code&gt;&#39;-- -&lt;/code&gt;, the WAF blocked us from using that payload. I tried to bypass the WAF by using different forms of comments like &lt;code&gt;#&lt;/code&gt; and &lt;code&gt;/*&lt;/code&gt; but none of them worked and the WAF still blocked us.&lt;/p&gt;
&lt;p&gt;The host where I confirmed SQLi was &lt;code&gt;api-gateway-c.[REDACTED].com&lt;/code&gt;. However, there was another host in scope which was very similar to our host. The other host was &lt;code&gt;api-gateway.[REDACTED].com&lt;/code&gt;. I checked if the auth token obtained from &lt;code&gt;api-gateway-c.[REDACTED].com&lt;/code&gt; worked on &lt;code&gt;api-gateway.[REDACTED].com&lt;/code&gt; and to my surprise, it actually did!&lt;/p&gt;
&lt;p&gt;I checked if the endpoints where I confirmed SQL injection was present on &lt;code&gt;api-gateway.[REDACTED].com&lt;/code&gt; or not. The endpoints were actually present! I sent the SQL injection payload &lt;code&gt;&#39;-- -&lt;/code&gt; to the new host and the server sent 400 again. This successfully confirmed that the new server was also vulnerable to SQL injection and was not protected with WAF. This allowed me to enumerate the database freely without any issues.&lt;/p&gt;
&lt;p&gt;The issues are still not resolved. For some reason, &lt;code&gt;sqlmap&lt;/code&gt; did not detect the injection point so I decided to manually enumerate the database.&lt;/p&gt;
&lt;p&gt;I could get the server to delay response using a payload like &lt;code&gt;&#39;; WAITFOR DELAY &#39;00:00:10&#39;-- -&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now, I needed to find a way to dump data using the delay. For that, I used MSSQL&amp;rsquo;s &lt;code&gt;IF&lt;/code&gt; statement. I constructed a payload that delayed the webserver for 10 seconds if the database username started with the character that I supplied. For example, the server would sleep for 10 seconds if the first letter of the database username was &amp;lsquo;A&amp;rsquo;.&lt;/p&gt;
&lt;p&gt;The payload that I constructed was as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;IF&lt;/span&gt;((&lt;span style=&#34;color:#66d9ef&#34;&gt;SELECT&lt;/span&gt; SYSEM_USER) &lt;span style=&#34;color:#66d9ef&#34;&gt;LIKE&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;%&amp;#39;&lt;/span&gt;) WAITFOR DELAY &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;00:00:10&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I enumerated the whole database username this way. One character at a time. To enumerate one single character, it required me to send 64 requests. However, thanks to Burp Suite&amp;rsquo;s Intruder, I did not have to manually change the character and send 64 times. I just created a wordlist of lowercase and uppercase characters along with &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;_&lt;/code&gt; as special characters and gave it to Intruder. Then, I sorted the results by the &lt;strong&gt;Response received&lt;/strong&gt; column.&lt;/p&gt;
&lt;p&gt;After running the Intruder 10 times, we get the 10 characters long database username.&lt;/p&gt;
&lt;p&gt;Normally, Synack Red Team requires actual table dumps to accept an SQL injection vulnerability. But in this case, they still accepted without me showing the database dumps because of the ridiculously slow data retrieval.&lt;/p&gt;
&lt;h4 id=&#34;reflected-xss-via-e-mail-parameter-with-aspnet-waf-bypass&#34;&gt;Reflected XSS via E-Mail parameter with ASP.NET WAF Bypass&lt;/h4&gt;
&lt;p&gt;I detect XSS vulnerabilities using a fairly simple payload like &lt;code&gt;d0mxss&#39;&amp;quot;&amp;gt;&amp;lt;&lt;/code&gt;. This payload allows me to find out the context in which the input is reflected. I used the same payload to detect this XSS. The payload was reflected in an input tag like:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;input&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;E-mail&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;d0mxss&amp;#39;&amp;#34;&lt;/span&gt;&amp;gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;lt;&lt;/span&gt;&amp;#34;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The ASP.NET WAF blocked common payloads like &lt;code&gt;&amp;quot; onclick=&amp;quot;alert(1)&lt;/code&gt;. To bypass the WAF, I used the following payload:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;#34; onmouseenter=&amp;#34;alert(document.domain)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The above payload will make the reflected HTML look like:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;input&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;E-mail&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;onmouseenter&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;alert(document.domain)&amp;#34;&lt;/span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When the user moves the pointer above the &lt;code&gt;E-mail&lt;/code&gt; input, the XSS gets triggered.&lt;/p&gt;
&lt;h4 id=&#34;login-authentication-bypass-in-client-side-ui&#34;&gt;Login Authentication Bypass In Client Side UI&lt;/h4&gt;
&lt;p&gt;This was a really lame vulnerability that should not exist at all. All the authentication mechanism was implemented in the frontend using JavaScript and no checking was done on the backend whatsoever. Even a simple login request was not sent to the backend.&lt;/p&gt;
&lt;p&gt;When we visited the web application, the application asked for a password in a JavaScript prompt. However, if we just click &amp;ldquo;&lt;strong&gt;cancel&lt;/strong&gt;&amp;rdquo; in the JavaScript prompt, we get access to the user interface.&lt;/p&gt;
&lt;p&gt;In fact, the UI had the functionality to execute SQL statements and all of this was possible by just clicking &amp;ldquo;&lt;strong&gt;cancel&lt;/strong&gt;&amp;rdquo;.&lt;/p&gt;
&lt;h4 id=&#34;access-control-issue-allows-to-execute-sql-statements&#34;&gt;Access Control Issue Allows To Execute SQL Statements&lt;/h4&gt;
&lt;p&gt;This was the same UI that we talked about in the previous vulnerability. I felt like a normal user should not be able to access the UI to execute SQL statements. This was because the interface was at the &lt;code&gt;/admin&lt;/code&gt; endpoint and this endpoint was discovered from JavaScript files and there were not any links/references to this endpoint in the UI.&lt;/p&gt;
&lt;p&gt;I found this concerning so I reported this issue and they actually accepted it considering it valid.&lt;/p&gt;
&lt;h4 id=&#34;connectors-endpoints-leaking-database-connection-information&#34;&gt;/connectors endpoints leaking Database Connection Information&lt;/h4&gt;
&lt;p&gt;When doing directory brute force with the &lt;code&gt;raft-small-words.txt&lt;/code&gt; wordlist provided in the &lt;a href=&#34;https://github.com/danielmiessler/SecLists&#34;&gt;SecLists&lt;/a&gt;, I came across an endpoint called &lt;code&gt;/connectors&lt;/code&gt;. When visited, this endpoint listed the following connectors:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jdbc_sink_auroradb&lt;/li&gt;
&lt;li&gt;local-file-sink&lt;/li&gt;
&lt;li&gt;mdb_sink_new&lt;/li&gt;
&lt;li&gt;s3_sink_sf_case_cdc1&lt;/li&gt;
&lt;li&gt;test-vk&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I then felt like these connectors should be accessible via URL. So, I visited the following URL: &lt;code&gt;http://[REDACTED]/connectors/jdbc_sink_auroradb&lt;/code&gt;. And the endpoint listed the PostgreSQL credentials. I checked for PostgreSQL instances on the network if there were any.&lt;/p&gt;
&lt;p&gt;To find PostgreSQL servers, I ran the following &lt;code&gt;masscan&lt;/code&gt; command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;sudo masscan -iL scope.txt -p &lt;span style=&#34;color:#ae81ff&#34;&gt;5432&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In the &lt;code&gt;masscan&lt;/code&gt; result, there were a couple of IPs. I used the credentials obtained from the &lt;code&gt;/connectors&lt;/code&gt; endpoint to log into these servers. And, the credentials actually worked!&lt;/p&gt;
&lt;p&gt;For logging in, I used the following command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;psql -h &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;REDACTED&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; -p &lt;span style=&#34;color:#ae81ff&#34;&gt;5432&lt;/span&gt; -U root postgres
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;local-file-inclusion-in-downloadphp&#34;&gt;Local File Inclusion In download.php&lt;/h4&gt;
&lt;p&gt;I found the &lt;code&gt;download.php&lt;/code&gt; file being reported as an SSRF in the analytics. However, it was rejected. I then investigated a bit more and found out that the &lt;code&gt;download.php&lt;/code&gt; takes a GET parameter named &lt;code&gt;f&lt;/code&gt; and the value of &lt;code&gt;f&lt;/code&gt; is a file that will be retrieved by the PHP script. Upon investigating the LFI, I found out that the script had the following line in the source code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-php&#34; data-lang=&#34;php&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;file_get_contents&lt;/span&gt;($_GET[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;f&amp;#39;&lt;/span&gt;]);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;So, I just put &lt;code&gt;f=download.php&lt;/code&gt; to show the PoC.&lt;/p&gt;
&lt;h4 id=&#34;ssrf-allowing-to-access-internal-service&#34;&gt;SSRF Allowing To Access Internal Service&lt;/h4&gt;
&lt;p&gt;This was a vulnerability in Oracle Application Server 10g Mapviewer.&lt;/p&gt;
&lt;p&gt;For proof of concept, I performed a full port scan of the server to confirm that the &lt;code&gt;8002&lt;/code&gt; port was not exposed to the internet. I then put the URL &lt;code&gt;http://127.0.0.1:8002/mapviewer/omserver&lt;/code&gt; as the Mapviewer URL and submitted the request. The request succeeded and a response was received from the &lt;code&gt;8002&lt;/code&gt; port confirming the SSRF vulnerability.&lt;/p&gt;
&lt;p&gt;If we provided a port that was not open or did not serve HTTP, the response timed out.&lt;/p&gt;
&lt;h4 id=&#34;pre-auth-server-side-request-forgery&#34;&gt;Pre-auth Server Side Request Forgery&lt;/h4&gt;
&lt;p&gt;This was a &lt;code&gt;nuclei&lt;/code&gt; finding.&lt;/p&gt;
&lt;p&gt;This was however interesting because the same day, I was onboarded on two different programs from the same organization. One was an internal test meaning we had to test their internal network that is not reachable by the public. And the other was an external test that had public-facing IPs.&lt;/p&gt;
&lt;p&gt;One of such public-facing IPs was vulnerable to Microsoft Exchange&amp;rsquo;s CVE-2021-26855. This was a pre-auth SSRF and you can find the PoC on the internet.&lt;/p&gt;
&lt;p&gt;I could have reported this right away but I felt like I should fully exploit the impact of an SSRF. So, I took the list of IPs from the internal test and put them into the SSRF exploit to find out the HTTP servers.&lt;/p&gt;
&lt;p&gt;Synack&amp;rsquo;s VPN was not correctly configured and the internal IPs were not accessible by us. However, by exploiting this SSRF, I could reach those IPs as well.&lt;/p&gt;
&lt;p&gt;From this point, I did not go ahead to enumerate these IPs as post-exploitation is not allowed on Synack Red Team.&lt;/p&gt;
&lt;p&gt;Reported the issue and won the quality round.&lt;/p&gt;
&lt;p&gt;Thanks for the read. :)&lt;/p&gt;
&lt;p&gt;You can reach out to me at &lt;a href=&#34;https://twitter.com/kuldeepdotexe&#34;&gt;@kuldeepdotexe&lt;/a&gt;.&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
